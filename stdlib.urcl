@define MALLOC_MAINP M0
@define F16PI 0b0100001001001000
@define F16E  0b0100000101110000

.strlen
    psh r1 // str *
    psh r2 // additional reg
    psh r3
    imm r3 0
    .strlen__loop1
        lod r2 r1
        bre .strlen__end r2 0
        inc r3 r3
        inc r1 r1
        jmp .strlen__loop1
    .strlen__end
        mov r1 r3
        pop r3
        pop r2
        pop r9
        ret

.strcpy
    psh r1 // dest str*
    psh r2 // src str*
    psh r3 // additional reg
    .strcpy__loop1
        lod r3 r2
        bre .strcpy__end r3 0
        str r1 r3
        inc r2 r2
        inc r1 r1
        jmp .strcpy__loop1
    .strcpy__end
        pop r3
        pop r2
        pop r1
        ret

.print_str
    // input data: r1 -> char*
    psh r1
    psh r2 // reserve reg
    imm r2 0
    .print_str__loop1
        lod r2 r1
        bre .print_str__endp r2 0
        out %text r2
        inc r1 r1
        jmp .print_str__loop1
    .print_str__endp
        pop r2
        pop r1
        ret

.printf // r1 = char*
    pop r9 // ret*
    str 0xee0 r1 
    str 0xee1 r2
    str 0xee2 r3
    imm r2 0
    .printf__loop1
        lod r2 r1
        bre .printf_str__endp r2 0
        bre .printf__perc r2 '%'
        out %text r2
        inc r1 r1
        jmp .printf__loop1
    .printf__perc
        inc r1 r1
        lod r2 r1
        bre .printf__percsub__d r2 'd'
        bre .printf__percsub__s r2 's'
        bre .printf__percsub__c r2 'c'
        bre .printf__percsub__perc r2 '%'
        jmp .printf__percsub__err
    .printf__percsub__perc
        out %text '%'
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__d
        pop r3
        out %numb r3
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__c
        pop r3
        out %text r3
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__s
        pop r3
        str 0xee3 r1
        mov r1 r3
        cal .print_str
        lod r1 0xee3
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__err
        imm r1 .printf__percsub__err_str
        psh r2
        cal .printf
    .printf_str__endp
        lod r3 0xee2
        lod r2 0xee1
        lod r1 0xee0
        jmp r9
    .printf__percsub__err_str
        dw [ "Wrong percentage-value %c" 0 ]
// only header gonna be 0bFaaa_aaaa_aaaa_aaaa, where 'F' is isfree bit and 'a' is address bit
.init_malloc
str MALLOC_MAINP 0xffff
ret

.malloc
    psh r1 // size
    psh r2 // dynamic malloc_start*
    imm r2 MALLOC_MAINP
    psh r3 // additional reg
    psh r4
    .malloc__loop1
        lod r3 r2
        brg .malloc__found__free r3 0x8000
        and r3 r3 0x7fff
        mov r2 r3
        jmp .malloc__loop1
    
    .malloc__found__free
        and r3 r3 0x7fff // getting address of next chunk (can work as size indicator)
        sub r4 r3 r2 // size of chunk available
        brl .malloc__found r1 r4
        // bre .malloc__found__partition__needed r1 r4
        bre .malloc__fail r3 0x7fff // check for failure
        bre .malloc__fail r3 0x0000
        mov r2 r3
        jmp .malloc__loop1
    .malloc__fail
        pop r4
        pop r3
        pop r2
        pop r1
        imm r1 0xffff // -1
        ret
    .malloc__found
        bne .malloc__found__skip r3 0x7fff // if ( address_of_the_next_chunk == 0x7fff) {
        // r1 - size, r2 - pointer to curr chunk, r3 - addr to next chunk, r4 - size of chunk
        psh r4
        mov r4 r1
        add r4 r4 r2
        and r4 r4 0x7fff
        add r4 r4 1
        str r2 r4
        str r4 0xffff
        pop r4
        jmp .malloc__end
        // }
        .malloc__found__skip 
        bre .malloc__found__skip2 r1 r4 // if ( chunk_size != req_size ) { -> fragmentation
        psh r4
        psh r3
        or r3 r3 0x8000 // making header from address
        mov r4 r1 // 
        add r4 r4 r2 // pointer to next header
        and r4 r4 0x7fff 
        add r4 r4 1 // making offset
        str r2 r4
        lod r5 r4
        bne .malloc__found__endstack r5 0xffff // if ( r4* == END_OF_MALLOC_STACK ) {
        str r4 0xffff
        jmp .malloc__found__endstack_2
        .malloc__found__endstack // } else {
        str r4 r3
        .malloc__found__endstack_2 // }
        pop r3
        pop r4
        jmp .malloc__end
        .malloc__found__skip2 // } else { -> simple address storing
        and r3 r3 0x8000
        str r2 r3
        .malloc__end
        pop r4
        pop r3
        mov r1 r2
        inc r1 r1
        pop r2
        pop r9
        ret

.free   
    psh r1 // pointer
    psh r2 // additional data
    psh r3
    psh r4
    lod r2 r1
    brg .free__alreadyfree r2 0x7fff
    sub r3 r2 r1 // size
    mov r4 r1
    .free__loop1
        str r4 0
        inc r4 r4
        dec r3 r3
        bre .free__freed r3 0
        jmp .free__loop1
.free__freed
    or r2 r2 0x8000
    str r1 r2
.free__alreadyfree
    cal .defragm_global
    pop r4
    pop r3
    pop r2
    pop r1
    ret
        

.defragm
    psh r1 // pointer
    psh r2
    lod r2 r1 // pointer to the next block
    psh r2 
    and r2 r2 0x7fff
    lod r2 r2
    brl .defragm_done2 r2 0x8000
    str r1 r2
    pop r2
    and r2 r2 0x7fff
    str r2 0
    jmp .defragm_done
.defragm_done2
    pop r2
.defragm_done
    pop r2
    pop r1
    ret


.defragm_global
    psh r1 // global malloc start ptr
    imm r1 MALLOC_MAINP
    psh r2 // additional data
    .defragm_global__loop1
        lod r2 r1
        bre .defragm_global__end r2 0xffff 
        brg .defragm_global__loopsub_found r2 0x8000
        
        and r2 r2 0x7fff
        mov r1 r2
        jmp .defragm_global__loop1
    .defragm_global__loopsub_found
        psh r1
        psh r2
        cal .defragm
        pop r2
        pop r1
        lod r2 r1
        and r2 r2 0x7fff
        bre .defragm_global__end r2 0x7fff
        mov r1 r2
        jmp .defragm_global__loop1 
.defragm_global__end
    pop r2
    pop r1
    ret
    
.memcpy
    psh r1 // dest *
    psh r2 // src *
    psh r3 // size
    psh r4 // additional
    .memcpy__loop1
        lod r4 r2
        str r1 r4
        dec r3 r3
        inc r1 r1
        inc r2 r2
        bre .memcpy__done r3 0
        jmp .memcpy__loop1
.memcpy__done
    pop r4
    pop r3
    pop r2
    pop r1
    ret

// FLOAT IMPLEMENTATION: 
// SXXXXXMMMMMMMMMM

.float_construct
    psh r1 // main int
    psh r2 // v
    psh r3 // sig 
    psh r4 // e
    brl .float_construct__else1 r1 0x8000
    and r2 r1 0x7fff
    imm r3 1
    jmp .float_construct__else1_conti
    .float_construct__else1
        mov r2 r1
    .float_construct__else1_conti
    bre .float_construct_end_0 r2 0
    imm r4 25
    bge .while_v_over2048 r2 2048
    jmp .while_v_less1024
    .while_v_over2048
        rsh r2 r2
        inc r4 r4
        bge .while_v_over2048 r2 2048
    .while_v_less1024pre
    brl .while_v_less1024 r2 1024
    jmp .while_end
    .while_v_less1024
    lsh r2 r2
    dec r4 r4
    brl .while_v_less1024 r2 1024
    .while_end
    bge .e_over_31 r4 31
    bsl r3 r3 15
    bsl r4 r4 10
    and r2 r2 1023
    or r2 r2 r3
    or r2 r2 r4
    mov r1 r2
    pop r4
    pop r3
    pop r2
    pop r9
    ret
    .e_over_31
    bsl r3 r3 15
    and r3 r3 0x8000
    or r3 r3 0x7c00
    mov r1 r3
    pop r4
    pop r3
    pop r2
    pop r9
    ret
    .float_construct_end_0
        pop r4
        pop r3
        pop r2
        pop r1
        imm r1 0
        ret

.f16_from_short
psh r1
psh r2
psh r3
psh r4
brg .f16_from_int__if1_else r3 0 
sub r2 0 r1
imm r3 1
jmp .f16_from_int__if1_end
.f16_from_int__if1_else
mov r2 r1
.f16_from_int__if1_end
bre .f16_from_int__end0 r2 0
imm r4 25
brl .f16_from_int__while1_end r2 2048
.f16_from_int__while1_start
rsh r2 r2
inc r4 r4
bge .f16_from_int__while1_start r2 2048
.f16_from_int__while1_end
bge .f16_from_int__while2_end r2 1024
.f16_from_int__while2_start
lsh r2 r2
dec r4 r4
brl .f16_from_int__while2_start r2 1024
.f16_from_int__while2_end
bge .f16_from_int__if2 r4 31
bsl r3 r3 15
bsl r4 r4 10
and r2 r2 1023
or r2 r2 r3
or r2 r2 r4
mov r1 r2
pop r4
pop r3
pop r2
pop r9
ret
.f16_from_int__if2
bsl r3 r3 15
and r3 r3 0x8000
or r3 r3 0x7c00
mov r1 r3
pop r4
pop r3
pop r2
pop r9
ret
.f16_from_int__end0
pop r4
pop r3
pop r2
pop r1
imm r1 0
ret

.f16_to_int
psh r1 
psh r2 
psh r3
psh r4 
and r2 r1 1023 
and r4 r1 0x7c00 
setne r4 r4 0 
and r4 r4 1 
mlt r4 r4 1024 
or r4 r4 r2
and r2 r1 0x7c00
bsr r2 r2 10
sub r2 r2 25
sbrl .f16_to_int__if1_else r2 0
bre .f16_to_int__if1_end r2 0
bsl r4 r4 r2
jmp .f16_to_int__if1_end
.f16_to_int__if1_else
sub r2 0 r2
bsr r4 r4 r2
.f16_to_int__if1_end
and r1 r1 0x8000
brz .f16_to_int__end r1
sub r4 0 r4
.f16_to_int__end
mov r1 r4
pop r4
pop r3
pop r2
pop r9
ret