bits == 16
minheap 0xfff 
minstack 0xff
minreg 10
@define MALLOC_MAINP 0x5ff

._start
    cal .init_malloc
    cal .main
    hlt

.main
    imm r1 12
    cal .malloc
    inc r1 r1
    psh r1
    imm r2 .test_str
    imm r3 12
    cal .memcpy
    pop r1
    psh 'e'
    cal .printf
    psh r1
    imm r1 7
    cal .malloc
    cal .free
    imm r1 0
    pop r1
    dec r1 r1
    cal .free
    ret

.test_str
    dw [ "char: %%%c" 0xa0 0 ]

.print_str
    // input data: r1 -> char*
    psh r1
    psh r2 // reserve reg
    imm r2 0
    .print_str__loop1
        lod r2 r1
        bre .print_str__endp r2 0
        out %text r2
        inc r1 r1
        jmp .print_str__loop1
    .print_str__endp
        pop r2
        pop r1
        ret

.printf // r1 = char*
    pop r9 // ret*
    str 0xee0 r1 
    str 0xee1 r2
    str 0xee2 r3
    imm r2 0
    .printf__loop1
        lod r2 r1
        bre .printf_str__endp r2 0
        bre .printf__perc r2 '%'
        out %text r2
        inc r1 r1
        jmp .printf__loop1
    .printf__perc
        inc r1 r1
        lod r2 r1
        bre .printf__percsub__d r2 'd'
        bre .printf__percsub__s r2 's'
        bre .printf__percsub__c r2 'c'
        bre .printf__percsub__perc r2 '%'
        jmp .printf__percsub__err
    .printf__percsub__perc
        out %text '%'
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__d
        pop r3
        out %numb r3
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__c
        pop r3
        out %text r3
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__s
        pop r3
        str 0xee3 r1
        mov r1 r3
        cal .print_str
        lod r1 0xee3
        inc r1 r1
        jmp .printf__loop1
    .printf__percsub__err
        imm r1 .printf__percsub__err_str
        psh r2
        cal .printf
    .printf_str__endp
        lod r3 0xee2
        lod r2 0xee1
        lod r1 0xee0
        jmp r9
    .printf__percsub__err_str
        dw [ "Wrong percentage-value %c" 0 ]
// only header gonna be 0bFaaa_aaaa_aaaa_aaaa, where 'F' is isfree bit and 'a' is address bit
.init_malloc
str MALLOC_MAINP 0xffff
ret

.malloc
    psh r1 // size
    psh r2 // dynamic malloc_start*
    imm r2 MALLOC_MAINP
    psh r3 // additional reg
    psh r4
    .malloc__loop1
        lod r3 r2
        brg .malloc__found__free r3 0x8000
        and r3 r3 0x7fff
        mov r2 r3
        jmp .malloc__loop1
    
    .malloc__found__free
        and r3 r3 0x7fff // getting address of next chunk (can work as size indicator)
        sub r4 r3 r2 // size of chunk available
        brl .malloc__found r1 r4
        // bre .malloc__found__partition__needed r1 r4
        bre .malloc__fail r3 0x7fff // check for failure
        bre .malloc__fail r3 0x0000
        mov r2 r3
        jmp .malloc__loop1
    .malloc__fail
        pop r4
        pop r3
        pop r2
        pop r1
        imm r1 0xffff // -1
        ret
    .malloc__found
        bne .malloc__found__skip r3 0x7fff // if ( address_of_the_next_chunk == 0x7fff) {
        // r1 - size, r2 - pointer to curr chunk, r3 - addr to next chunk, r4 - size of chunk
        psh r4
        mov r4 r1
        add r4 r4 r2
        and r4 r4 0x7fff
        add r4 r4 1
        str r2 r4
        str r4 0xffff
        pop r4
        jmp .malloc__end
        // }
        .malloc__found__skip 
        bre .malloc__found__skip2 r1 r4 // if ( chunk_size != req_size ) { -> fragmentation
        psh r4
        psh r3
        or r3 r3 0x8000 // making header from address
        mov r4 r1 // 
        add r4 r4 r2 // pointer to next header
        and r4 r4 0x7fff 
        add r4 r4 1 // making offset
        str r2 r4
        lod r5 r4
        bne .malloc__found__endstack r5 0xffff // if ( r4* == END_OF_MALLOC_STACK ) {
        str r4 0xffff
        jmp .malloc__found__endstack_2
        .malloc__found__endstack // } else {
        str r4 r3
        .malloc__found__endstack_2 // }
        pop r3
        pop r4
        jmp .malloc__end
        .malloc__found__skip2 // } else { -> simple address storing
        and r3 r3 0x8000
        str r2 r3
        .malloc__end
        pop r4
        pop r3
        mov r1 r2
        pop r2
        pop r9
        ret

.free   
    psh r1 // pointer
    psh r2 // additional data
    psh r3
    psh r4
    lod r2 r1
    brg .free__alreadyfree r2 0x7fff
    sub r3 r2 r1 // size
    mov r4 r1
    .free__loop1
        str r4 0
        inc r4 r4
        dec r3 r3
        bre .free__freed r3 0
        jmp .free__loop1
.free__freed
    or r2 r2 0x8000
    str r1 r2
.free__alreadyfree
    cal .defragm_global
    pop r4
    pop r3
    pop r2
    pop r1
    ret
        

.defragm
    psh r1 // pointer
    psh r2
    lod r2 r1 // pointer to the next block
    psh r2 
    and r2 r2 0x7fff
    lod r2 r2
    brl .defragm_done2 r2 0x8000
    str r1 r2
    pop r2
    and r2 r2 0x7fff
    str r2 0
    jmp .defragm_done
.defragm_done2
    pop r2
.defragm_done
    pop r2
    pop r1
    ret


.defragm_global
    psh r1 // global malloc start ptr
    imm r1 MALLOC_MAINP
    psh r2 // additional data
    .defragm_global__loop1
        lod r2 r1
        bre .defragm_global__end r2 0xffff 
        brg .defragm_global__loopsub_found r2 0x8000
        
        and r2 r2 0x7fff
        mov r1 r2
        jmp .defragm_global__loop1
    .defragm_global__loopsub_found
        psh r1
        psh r2
        cal .defragm
        pop r2
        pop r1
        lod r2 r1
        and r2 r2 0x7fff
        bre .defragm_global__end r2 0x7fff
        mov r1 r2
        jmp .defragm_global__loop1 
.defragm_global__end
    pop r2
    pop r1
    ret
    
.memcpy
    psh r1 // dest *
    psh r2 // src *
    psh r3 // size
    psh r4 // additional
    .memcpy__loop1
        lod r4 r2
        str r1 r4
        dec r3 r3
        inc r1 r1
        inc r2 r2
        bre .memcpy__done r3 0
        jmp .memcpy__loop1
.memcpy__done
    pop r4
    pop r3
    pop r2
    pop r1
    ret    



